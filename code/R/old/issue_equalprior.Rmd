---
title: "contr.equal_prior"
output: html_document
date: "2024-03-04"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

I have some questions regarding the contr.equalprior function.

First, I am setting up the brms models. I am attaching an .rds file for the models, such that you don't need to run them again.

```{r, message=FALSE}
library(emmeans)
library(easystats)
library(brms)
library(tidyverse)
library(here)
library(see)
```

```{r}

# set-up:
project_seed = 2049
set.seed(project_seed) 

# Make df, with 12 subjects, with:
# Group (between subj factor): levels "fam" and "unfam"
# TestSpeaker (within): levels 1,2,3
# sleepState (between): levels awake, activesleep, quietsleep
# MMR: dependent variable
df = structure(list(Subj = structure(c(1L, 1L, 1L, 2L, 2L, 2L, 3L, 
                                       3L, 3L, 4L, 4L, 4L, 5L, 5L, 5L, 6L, 6L, 6L, 7L, 7L, 7L, 8L, 8L, 
                                       8L, 9L, 9L, 9L, 10L, 10L, 10L, 11L, 11L, 11L, 12L, 12L, 12L), 
                                     levels = c("Subj01","Subj02", "Subj03", "Subj04", "Subj05", "Subj06", 
                                                "Subj07", "Subj08","Subj09", "Subj10", "Subj11", "Subj12"), 
                                     class = "factor"),
                    Group = structure(c(1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 
                                        1L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 
                                        2L, 2L, 2L), levels = c("fam", "unfam"), class = "factor"), 
                    TestSpeaker = structure(c(1L, 2L, 3L, 1L, 2L, 3L, 1L, 2L, 3L, 1L, 2L, 3L, 1L, 2L, 3L, 1L, 2L, 
                                              3L, 1L, 2L, 3L, 1L, 2L, 3L, 1L, 2L, 3L, 1L, 2L, 3L, 1L, 2L, 3L, 
                                              1L, 2L, 3L), levels = c("1", "2", "3"), class = "factor"),
                    MMR = c(38.3193739833394,-26.3345733319488, -36.5391489690257, 17.6727210461579, 13.0723969801114, 
                            -4.24116674572545, 21.2481968372323, 11.4709975141478, 1.82856457361663, 
                            43.7294164718069, 20.3131479540544, 0.785675781481198, -2.15902787287105, 
                            -25.4903371611785, 61.873025266565, 9.06733331354276, -18.7574284113092, 
                            6.33216574768327, -34.9097027199614, -3.96327639212982, 15.9747552016853, 
                            -38.801070417319, -6.46518128748102, -22.630432474398, 21.9291933267653, 
                            24.4946719999554, -31.2847387815119, -8.04032285881707, 14.2321054924562, 
                            8.80183458992482, 18.9550435474235, 33.2621031208136, -11.4198082197363, 
                            -14.7150081652997, 29.2510483128696, -31.1494998323233), 
                    sleepState = structure(c(2L,2L, 2L, 3L, 3L, 3L, 2L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 1L, 1L, 
                                             1L, 1L, 1L, 1L, 1L, 1L, 1L, 3L, 3L, 3L, 1L, 1L, 1L, 2L, 2L, 2L, 
                                             1L, 1L, 1L), levels = c("awake", "activesleep", "quietsleep"), class = "factor")),
               row.names = c(NA,-36L), class = c("tbl_df", "tbl", "data.frame"))

# ### MODEL 1: With  contr.equalprior set globally
# options(contrasts = c("contr.equalprior", "contr.poly"))
# # Same as:
# # contrasts(df$TestSpeaker) <- contr.equalprior
# # contrasts(df$Group) <- contr.equalprior
# # contrasts(df$sleepState) <- contr.equalprior
# 
# m1 = brm(MMR ~ 1 + TestSpeaker * Group + 
#         sleepState * TestSpeaker + 
#         (1 + TestSpeaker * Group | Subj),
#       data = df,
#       family = gaussian(), 
#       prior = c(set_prior("normal(5.97, 23.34)",  
#                           class = "Intercept"),
#                 set_prior("normal(0, 23.34)",  
#                           class = "b"),
#                 set_prior("normal(0, 23.34)",  
#                           class = "sigma")),
#       init = "random",
#       control = list(
#         adapt_delta = .99, 
#         max_treedepth = 15
#       ),
#       chains = 4,
#       iter = 4000,
#       warmup = 2000,
#       thin = 1,
#       algorithm = "sampling", 
#       cores = 4, 
#       seed = project_seed,
#       save_pars = save_pars(all = TRUE),
#       file = here("data", "model_output", "m1.rds")
# )
# 
# ### MODEL 2: With  contr.equalprior_pairs set globally
# 
# options(contrasts = c("contr.equalprior_pairs", "contr.poly"))
# # Same as:
# # contrasts(df$TestSpeaker) <- contr.equalprior_pairs
# # contrasts(df$Group) <- contr.equalprior_pairs
# # contrasts(df$sleepState) <- contr.equalprior_pairs
# 
# m2 = brm(MMR ~ 1 + TestSpeaker * Group + 
#         sleepState * TestSpeaker + 
#         (1 + TestSpeaker * Group | Subj),
#       data = df,
#       family = gaussian(), 
#       prior = c(set_prior("normal(5.97, 23.34)",  
#                           class = "Intercept"),
#                 set_prior("normal(0, 23.34)",  
#                           class = "b"),
#                 set_prior("normal(0, 23.34)",  
#                           class = "sigma")),
#       init = "random",
#       control = list(
#         adapt_delta = .99, 
#         max_treedepth = 15
#       ),
#       chains = 4,
#       iter = 4000,
#       warmup = 2000,
#       thin = 1,
#       algorithm = "sampling", 
#       cores = 4, 
#       seed = project_seed,
#       save_pars = save_pars(all = TRUE),
#       file = here("data", "model_output", "m2.rds")
#   )

#import the models from file
# m1 <- readRDS(here("m1.rds"))
# m2 <- readRDS(here("m2.rds"))
m1 <- readRDS(here("m1.rds"))
m2 <- readRDS(here("m2.rds"))

```


### Question 1
First, I have a question about the difference between contr.equalprior and contr.equalprior_pairs. 

The contrast matrices are different:
```{r}
contrasts(df$TestSpeaker) <- contr.equalprior_pairs
contrasts(df$TestSpeaker)

contrasts(df$TestSpeaker) <- contr.equalprior
contrasts(df$TestSpeaker)
```

Since the contrast matrices are different, the outcomes for the priors are of course different. I understand that since I am mostly comparing pairs, I should probably use contr.equalprior_pairs. However, contr.equalprior also seems to give me equal priors (also for my other comparisons below), just with different values:


```{r}
m_prior <- unupdate(m1, verbose=FALSE) # sample priors from model
m_prior_pairwise <-
  m_prior %>%
  emmeans(~ TestSpeaker)  %>%
  pairs()

point_estimate(m_prior_pairwise, centr = "mean", disp = TRUE)

m_prior <- unupdate(m2, verbose=FALSE) # sample priors from model
m_prior_pairwise <-
  m_prior %>%
  emmeans(~ TestSpeaker)  %>%
  pairs()

point_estimate(m_prior_pairwise, centr = "mean", disp = TRUE)
```
**My question: What is the exact difference between contr.equalprior_pairs and contr.equalprior, and based on which criteria should I choose one or the other? Especially given the fact (see below) that the contrasts influence the BFs..**


### Question 2
Now I have a question about setting priors on contrasts that are comparing different combinations of factors.
In the following example, I compare some pairs of the interaction between TestSpeaker*Group. For this, I create a custom contrast matrix:
```{r}
MMR.emm1 = m2 %>%
  emmeans(~ Group:TestSpeaker) 
MMR.emm1 # to set the custom contrast correctly

fam1 = c(1,0,0,0,0,0)
unfam1 = c(0,1,0,0,0,0)
fam2 = c(0,0,1,0,0,0)
unfam2 = c(0,0,0,1,0,0)
fam3 = c(0,0,0,0,1,0)
unfam3 = c(0,0,0,0,0,1)

custom_contrasts <- list(
  list("unfam2-fam1" = unfam2 - fam1),
  list("unfam2-unfam3" = unfam2 - unfam3),
  list("unfam1-unfam2" = unfam1 - unfam2),
  list("fam2-fam3" = fam2-fam3),
  list("((unfam2-unfam3)-(fam2-fam3))" = ((unfam2 - unfam3) - (fam2 - fam3)))
) 
```  
Now I want to compute the BF for these contrasts.
First, for m1:

```{r}
#  comparison of prior distributions
m1_prior <- unupdate(m1, verbose=FALSE) # sample priors from model
m1_prior_pairs <-
  m1_prior %>%
  emmeans(~ Group:TestSpeaker)
m1_prior_pairs = contrast(m1_prior_pairs, method = custom_contrasts)

#  comparison of posterior distributions
m1_post_pairs <-
  m1 %>%
  emmeans(~ TestSpeaker:Group) 
m1_post_pairs = contrast(m1_post_pairs, method = custom_contrasts)

# Bayes Factors (Savage-Dickey density ratio)
BF_m1 <-
  m1_post_pairs %>%
  bf_parameters(prior = m1_prior_pairs) %>%
  arrange(log_BF) # sort according to BF
BF_m1
plot(BF_m1)
```

Then, for m2:

```{r}
#  comparison of prior distributions
m2_prior <- unupdate(m2, verbose=FALSE) # sample priors from model
m2_prior_pairs <-
  m2_prior %>%
  emmeans(~ Group:TestSpeaker)
m2_prior_pairs = contrast(m2_prior_pairs, method = custom_contrasts)

#  comparison of posterior distributions
m2_post_pairs <-
  m2 %>%
  emmeans(~ TestSpeaker:Group) 
m2_post_pairs = contrast(m2_post_pairs, method = custom_contrasts)

# Bayes Factors (Savage-Dickey density ratio)
BF_m2 <-
  m2_post_pairs %>%
  bf_parameters(prior = m2_prior_pairs) %>%
  arrange(log_BF) # sort according to BF
BF_m2
plot(BF_m2)
```

Then I check the priors on these contrasts:
```{r}
point_estimate(m1_prior_pairs, centr = "mean", disp = TRUE)
point_estimate(m2_prior_pairs, centr = "mean", disp = TRUE)
```
I have 2 observations:

- For both models, contrast 2,3 and 4 have similar priors. The first and last contrasts, however, have different priors. I think this is because for the first contrast we compare participants in two different Groups with two different TestSpeakers, whereas for contrast 2,3,4, only TestSpeaker differs and Group is the same. And for the last contrast, we look at a difference between two contrasts.\n
My intuition is that it is completely fine that the priors on the contrasts differ, as long as I don't start comparing contrasts with different priors. In other words, I can test ((unfam2-unfam3)-(fam2-fam3)) and ((unfam2-unfam3)-(unfam1-unfam2), but I can't compare ((unfam2-unfam3)-(unfam2-fam1)) because these two contrasts have different priors.
- As already mentioned above, m1 (with contr.equalprior) and m2 (with contr.equalprior_pairs) both show equal priors in the same cases, but with different values. Even more important, the BF for the examined contrasts different between contr.equalprior and contr.equalprior_pairs are different! 


--------------------------------------------------

For the factor sleepState, I also compute custom contrasts:
```{r}
MMR.emm2 = m2 %>%
  emmeans(~ sleepState) 
MMR.emm2 # to set the custom contrast correctly

# set custom contrast sleep
custom_contrasts_sleep <- list(
  list("awake - activesleep and quietsleep" = c(1, -1/2, -1/2)),
  list("quietsleep - awake and activesleep" = c(-1/2, -1/2, 1)),
  list("quietsleep vs activesleep" =c(0, 1, -1))
)
```

I now compute the BF- here I don't compare pairwise, but according to the contrast: 
```{r}
#  comparison of prior distributions
m2_prior <- unupdate(m2, verbose=FALSE) # sample priors from model
m2_prior_sleep <-
  m2_prior %>%
  emmeans(~ sleepState)
m2_prior_sleep = contrast(m2_prior_sleep, method = custom_contrasts_sleep)

#  comparison of posterior distributions
m2_post_sleep <-
  m2 %>%
  emmeans(~ sleepState) 
m2_post_sleep = contrast(m2_post_sleep, method = custom_contrasts_sleep)

# Bayes Factors (Savage-Dickey density ratio)
BF_m2_sleep <-
  m2_post_sleep %>%
  bf_parameters(prior = m2_prior_sleep) %>%
  arrange(log_BF) # sort according to BF
BF_m2_sleep
plot(BF_m2_sleep)
```

Now I check the priors:
```{r}
point_estimate(m2_prior_sleep, centr = "mean", disp = TRUE)
```
Same thing here as for the other comparisons: the priors are not the same, but I find that intuitive: for the first two contrasts, I combine two of the levels, whereas for the 3rd contrast, I only compare to separate levels.

I assume that I can compare contrasts 1 and 2, but I can't compare contrast 1 and 3 or 2 and 3 (which would also make no sense in terms of hypotheses).

**In summary, my question: is it okay that the priors for different contrasts are different, if that is caused my the fact that for these contrasts I am comparing different combinations of levels of my factors, and as long as I don't compare contrasts that have different priors? And if not, is there a way to force the priors to be the same for an entire custom contrast matrix?**


### Question 3
I have two additional questions. 

- In the output of emmeans(), I always get the warning: `NOTE: Results may be misleading due to involvement in interactions`. Is this a problem for the contrasts I am comparing?
- The posterior distribution for the BF for model 2 has some weird bumps - do you know why they are there and whether it's a problem?





